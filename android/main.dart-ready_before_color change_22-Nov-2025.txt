import 'dart:async';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_sound/flutter_sound.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:audioplayers/audioplayers.dart';

void main() {
  runApp(VoiceAlarmApp());
}

class VoiceAlarmApp extends StatelessWidget {
  const VoiceAlarmApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(title: 'Multi Voice Alarm', home: AlarmScreen());
  }
}

class AlarmData {
  String title;
  DateTime? dateTime;
  int snoozeMinutes;
  DateTime? snoozedUntil;
  bool isOn;
  String filePath;
  bool isRecording;
  bool isPlaying;
  AudioPlayer? player;
  StreamSubscription<void>? onCompleteSub;
  bool isRecurring;
  List<int> repeatDays;

  AlarmData({
    required this.title,
    this.dateTime,
    this.snoozeMinutes = 5,
    this.snoozedUntil,
    this.isOn = false,
    required this.filePath,
    this.isRecording = false,
    this.isPlaying = false,
    this.player,
    this.onCompleteSub,
    this.isRecurring = false,
    List<int>? repeatDays,
  }) : repeatDays = repeatDays ?? [];
}

class AlarmScreen extends StatefulWidget {
  const AlarmScreen({super.key});

  @override
  _AlarmScreenState createState() => _AlarmScreenState();
}

class _AlarmScreenState extends State<AlarmScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _blinkController;
  late Animation<Color?> _colorAnimation;
  late FlutterSoundRecorder _recorder;
  List<AlarmData> alarms = [];
  late List<TextEditingController> _titleControllers;
  int currentIndex = 0;
  Timer? _alarmChecker;
  Timer? _snoozeChecker;

  Duration? _countdown;
  Duration? _totalCountdown; // ✅ new field
  Timer? _countdownTimer;

  @override
  void initState() {
    super.initState();
    _initRecorder();
    _initAlarms();
    _startAlarmMonitor();
    _startSnoozeMonitor();

    _blinkController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 1),
    )..repeat(reverse: true);

    _colorAnimation = ColorTween(
      begin: Colors.red.shade200,
      end: Colors.red.shade600,
    ).animate(_blinkController);
  }

  Future<void> _initRecorder() async {
    final micStatus = await Permission.microphone.request();
    if (!micStatus.isGranted) return;
    _recorder = FlutterSoundRecorder();
    await _recorder.openRecorder();
  }

  void _initAlarms() async {
    final dir = await getApplicationDocumentsDirectory();
    alarms = [];
    _titleControllers = [];
    for (int i = 0; i < 5; i++) {
      alarms.add(
        AlarmData(
          title: "Alarm ${i + 1}",
          filePath: '${dir.path}/alarm_${i + 1}.aac',
        ),
      );
      _titleControllers.add(TextEditingController(text: "Alarm ${i + 1}"));
    }
    setState(() {});
  }

  AlarmData get currentAlarm => alarms[currentIndex];
  TextEditingController get currentController =>
      _titleControllers[currentIndex];

  void _startAlarmMonitor() {
    _alarmChecker = Timer.periodic(const Duration(seconds: 1), (_) async {
      final now = DateTime.now();
      final int todayIndex = now.weekday % 7;

      for (final alarm in alarms) {
        if (!alarm.isOn || alarm.dateTime == null) continue;
        if (alarm.snoozedUntil != null && now.isBefore(alarm.snoozedUntil!)) {
          continue;
        }

        if (alarm.isRecurring) {
          if (alarm.repeatDays.isEmpty) continue;
          if (alarm.repeatDays.contains(todayIndex)) {
            if (now.hour == alarm.dateTime!.hour &&
                now.minute == alarm.dateTime!.minute &&
                now.second == 0) {
              await _playAlarmRecording(alarm);
              _setNextAlarmCountdown();
            }
          }
        } else {
          if (now.year == alarm.dateTime!.year &&
              now.month == alarm.dateTime!.month &&
              now.day == alarm.dateTime!.day &&
              now.hour == alarm.dateTime!.hour &&
              now.minute == alarm.dateTime!.minute &&
              now.second == 0) {
            await _playAlarmRecording(alarm);
            _setNextAlarmCountdown();
          }
        }
      }
    });
  }

  void _startSnoozeMonitor() {
    _snoozeChecker = Timer.periodic(const Duration(seconds: 1), (_) async {
      for (final alarm in alarms) {
        if (alarm.isOn &&
            alarm.snoozedUntil != null &&
            DateTime.now().isAfter(alarm.snoozedUntil!)) {
          alarm.snoozedUntil = null;
          await _playAlarmRecording(alarm);
          setState(() {});
        }
      }
    });
  }

  @override
  void dispose() {
    _alarmChecker?.cancel();
    _snoozeChecker?.cancel();
    _countdownTimer?.cancel();
    _recorder.closeRecorder();
    for (var alarm in alarms) {
      alarm.player?.stop();
      alarm.onCompleteSub?.cancel();
      alarm.player?.dispose();
    }
    _blinkController.dispose();
    super.dispose();
  }

  Future<void> _startRecording() async {
    await Future.delayed(const Duration(milliseconds: 300));
    await _recorder.startRecorder(
      toFile: currentAlarm.filePath,
      codec: Codec.aacADTS,
    );
    setState(() => currentAlarm.isRecording = true);
  }

  Future<void> _stopRecording() async {
    await _recorder.stopRecorder();
    setState(() => currentAlarm.isRecording = false);
  }

  Future<void> _playRecordingOnce() async {
    final file = File(currentAlarm.filePath);
    if (!file.existsSync()) return;
    final player = AudioPlayer();
    await player.setReleaseMode(ReleaseMode.stop);
    await player.play(DeviceFileSource(currentAlarm.filePath));
  }

  Future<void> _playAlarmRecording(AlarmData alarm) async {
    if (alarm.isPlaying) return;
    final file = File(alarm.filePath);
    if (!file.existsSync()) return;

    alarm.isPlaying = true;
    await alarm.player?.stop();
    await alarm.onCompleteSub?.cancel();

    alarm.player = AudioPlayer();
    await alarm.player!.setReleaseMode(ReleaseMode.stop);
    await alarm.player!.play(DeviceFileSource(alarm.filePath));

    alarm.onCompleteSub = alarm.player!.onPlayerComplete.listen((_) async {
      alarm.isPlaying = false;
      if (alarm.isOn &&
          alarm.snoozedUntil == null &&
          File(alarm.filePath).existsSync()) {
        await _playAlarmRecording(alarm);
      }
    });
  }

  void _alarmOff() {
    currentAlarm.snoozedUntil = null;
    currentAlarm.isOn = false;
    currentAlarm.player?.stop();
    currentAlarm.onCompleteSub?.cancel();
    currentAlarm.isPlaying = false;
    setState(() {});
  }

  Future<void> _deleteRecordingFile(AlarmData alarm) async {
    try {
      final file = File(alarm.filePath);
      if (file.existsSync()) {
        await file.delete();
      }
    } catch (_) {}
  }

  Future<void> _resetAlarm() async {
    currentAlarm.isOn = false;
    currentAlarm.player?.stop();
    await currentAlarm.onCompleteSub?.cancel();
    currentAlarm.isPlaying = false;

    currentAlarm.snoozedUntil = null;
    currentAlarm.dateTime = null;

    currentAlarm.title = "Alarm ${currentIndex + 1}";
    currentController.text = currentAlarm.title;

    currentAlarm.isRecurring = false;
    currentAlarm.repeatDays = [];

    currentAlarm.isRecording = false;
    await _deleteRecordingFile(currentAlarm);

    _countdownTimer?.cancel();
    _countdown = null;

    setState(() {});
  }

  Future<void> _pickAlarmDateTime() async {
    final pickedDate = await showDatePicker(
      context: context,
      initialDate: DateTime.now(),
      firstDate: DateTime.now(),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );

    if (pickedDate != null) {
      final pickedTime = await showTimePicker(
        context: context,
        initialTime: TimeOfDay.now(),
      );

      if (pickedTime != null) {
        setState(() {
          currentAlarm.dateTime = DateTime(
            pickedDate.year,
            pickedDate.month,
            pickedDate.day,
            pickedTime.hour,
            pickedTime.minute,
          );
          currentAlarm.isOn = true;
        });
        _startCountdown();
      }
    }
  }

  void _startCountdown() {
    _countdownTimer?.cancel();
    DateTime? target = currentAlarm.snoozedUntil ?? currentAlarm.dateTime;
    if (target == null) return;

    _countdown = target.difference(DateTime.now());
    _totalCountdown = _countdown; // ✅ store full duration once
    _countdownTimer = Timer.periodic(const Duration(seconds: 1), (_) {
      setState(() {
        DateTime? activeTarget =
            currentAlarm.snoozedUntil ?? currentAlarm.dateTime;
        if (activeTarget != null) {
          _countdown = activeTarget.difference(DateTime.now());
          if (_countdown!.isNegative) {
            _countdownTimer?.cancel();
            _countdown = null;
            _totalCountdown = null; // ✅ reset
            _setNextAlarmCountdown();
          }
        }
      });
    });
  }

  void _setNextAlarmCountdown() {
    final futureAlarms = alarms
        .where((a) => a.dateTime != null && a.dateTime!.isAfter(DateTime.now()))
        .toList();
    futureAlarms.sort((a, b) => a.dateTime!.compareTo(b.dateTime!));

    if (futureAlarms.isNotEmpty) {
      currentIndex = alarms.indexOf(futureAlarms.first);
      _startCountdown();
    }
  }

  String _formatDuration(Duration d) {
    final hours = d.inHours.toString().padLeft(2, '0');
    final minutes = (d.inMinutes % 60).toString().padLeft(2, '0');
    final seconds = (d.inSeconds % 60).toString().padLeft(2, '0');
    return "$hours:$minutes:$seconds";
  }

  void _snoozeAlarm() {
    if (!currentAlarm.isOn) return;
    currentAlarm.snoozedUntil = DateTime.now().add(
      Duration(minutes: currentAlarm.snoozeMinutes),
    );
    currentAlarm.player?.stop();
    currentAlarm.onCompleteSub?.cancel();
    currentAlarm.isPlaying = false;

    _countdown = currentAlarm.snoozedUntil!.difference(DateTime.now());

    setState(() {});
    _startCountdown();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Multi Voice Alarm')),
      body: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Navigation
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                IconButton(
                  icon: const Icon(Icons.arrow_left),
                  onPressed: () {
                    setState(() {
                      currentIndex =
                          (currentIndex - 1 + alarms.length) % alarms.length;
                    });
                  },
                ),
                Text(
                  "Alarm ${currentIndex + 1}",
                  style: const TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.arrow_right),
                  onPressed: () {
                    setState(() {
                      currentIndex = (currentIndex + 1) % alarms.length;
                    });
                  },
                ),
              ],
            ),
            const SizedBox(height: 10),

            // Title field
            TextField(
              controller: currentController,
              maxLength: 20,
              style: const TextStyle(fontWeight: FontWeight.bold),
              decoration: const InputDecoration(labelText: "Alarm Title"),
              onChanged: (val) {
                setState(() {
                  currentAlarm.title = val;
                });
              },
            ),
            const SizedBox(height: 10),

            // Repeat toggle
            Row(
              children: [
                const Text('Repeat:'),
                Switch(
                  value: currentAlarm.isRecurring,
                  onChanged: (val) {
                    setState(() => currentAlarm.isRecurring = val);
                  },
                ),
              ],
            ),

            // Weekday selector
            Wrap(
              spacing: 6,
              children: List.generate(7, (i) {
                const labels = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
                final bool selected = currentAlarm.repeatDays.contains(i);

                return ChoiceChip(
                  label: Text(
                    labels[i],
                    style: TextStyle(
                      color: selected ? Colors.white : Colors.black,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  selected: selected,
                  selectedColor: Colors.blue,
                  backgroundColor: Colors.grey.shade300,
                  onSelected: (isSelected) {
                    setState(() {
                      if (isSelected) {
                        currentAlarm.repeatDays.add(i);
                        currentAlarm.isRecurring = true;
                      } else {
                        currentAlarm.repeatDays.remove(i);
                        if (currentAlarm.repeatDays.isEmpty) {
                          currentAlarm.isRecurring = false;
                        }
                      }
                    });
                  },
                );
              }),
            ),
            const SizedBox(height: 20),

            // Record / Play buttons
            Row(
              children: [
                Expanded(
                  child: AnimatedBuilder(
                    animation: _colorAnimation,
                    builder: (context, child) {
                      return ElevatedButton(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: currentAlarm.isRecording
                              ? _colorAnimation.value
                              : Colors.blue,
                        ),
                        onPressed: currentAlarm.isPlaying
                            ? null
                            : (currentAlarm.isRecording
                                  ? _stopRecording
                                  : _startRecording),
                        child: Text(
                          currentAlarm.isRecording ? 'Stop' : 'Record',
                        ),
                      );
                    },
                  ),
                ),
                const SizedBox(width: 10),
                Expanded(
                  child: ElevatedButton(
                    onPressed: currentAlarm.isRecording
                        ? null
                        : _playRecordingOnce,
                    child: const Text('Play'),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 10),

            // Snooze / Off / Reset buttons
            Row(
              children: [
                Expanded(
                  child: ElevatedButton(
                    onPressed: _snoozeAlarm,
                    child: const Text('Snooze'),
                  ),
                ),
                const SizedBox(width: 10),
                Expanded(
                  child: ElevatedButton(
                    onPressed: _alarmOff,
                    child: const Text('Alarm Off'),
                  ),
                ),
                const SizedBox(width: 10),
                Expanded(
                  child: ElevatedButton(
                    onPressed: _resetAlarm,
                    child: const Text('Reset'),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 20),

            // Snooze dropdown + Set Alarm DateTime
            Row(
              children: [
                const Text('Snooze:'),
                const SizedBox(width: 10),
                DropdownButton<int>(
                  value: currentAlarm.snoozeMinutes,
                  items: List.generate(30, (i) => i + 1).map((min) {
                    return DropdownMenuItem(
                      value: min,
                      child: Text('$min min'),
                    );
                  }).toList(),
                  onChanged: (value) {
                    setState(() => currentAlarm.snoozeMinutes = value!);
                  },
                ),
                const Spacer(),
                ElevatedButton(
                  onPressed: _pickAlarmDateTime,
                  child: const Text('Set Alarm Time & Date'),
                ),
              ],
            ),
            const SizedBox(height: 10),

            // Alarm set info
            if (currentAlarm.dateTime != null)
              Text(
                'Alarm set to: ${currentAlarm.dateTime!.toLocal().toString().split('.').first}',
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
            // Countdown button + display
            Row(
              children: [
                ElevatedButton(
                  onPressed: _startCountdown,
                  child: const Text('Countdown'),
                ),
                const SizedBox(width: 20),
                if (_countdown != null)
                  SizedBox(
                    height: 60,
                    width: 60,
                    child: Stack(
                      alignment: Alignment.center,
                      children: [
                        CircularProgressIndicator(
                          value: _totalCountdown != null && _countdown != null
                              ? _countdown!.inSeconds /
                                    _totalCountdown!.inSeconds
                              : 0,
                          strokeWidth: 6,
                          backgroundColor: Colors.grey.shade300,
                          valueColor: AlwaysStoppedAnimation<Color>(
                            currentAlarm.snoozedUntil != null
                                ? Colors.orange
                                : Colors.green,
                          ),
                        ),
                        Text(
                          _formatDuration(_countdown!),
                          style: const TextStyle(
                            fontWeight: FontWeight.bold,
                            fontSize: 10,
                          ),
                        ),
                      ],
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 20),

            // Snoozed info
            if (currentAlarm.snoozedUntil != null)
              Text(
                'Snoozed until: ${currentAlarm.snoozedUntil!.toLocal().toString().split('.').first}',
                style: const TextStyle(fontWeight: FontWeight.bold),
              ),
            const SizedBox(height: 20),

            // Status row
            Row(
              children: [
                const Text('Alarm Status: ', style: TextStyle(fontSize: 16)),
                Icon(
                  currentAlarm.isOn ? Icons.alarm_on : Icons.alarm_off,
                  color: currentAlarm.isOn ? Colors.green : Colors.red,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
